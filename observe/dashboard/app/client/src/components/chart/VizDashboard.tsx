import { createStyles } from '@mantine/core';
import { chartColorForIndex } from '~/assets/Colors';
import { TimeSeriesChart } from '~/components/chart/TimeSeriesChart';
import { ChartTimeSeries } from '~/components/chart/types/chart-types';
import { useOrgId } from '~/hooks/useOrgId';
import { useSuperGlobalDateRange } from '~/hooks/useSuperDateRange';
import { useTrpcServerErrorHandler } from '~/hooks/useTrpcServerErrorHandler';
import { EmptySelectionGraphCard } from '~/routes/:orgId/dashboard/:dashboardId/components/EmptySelectionGraphCard';
import { rangeTranslatorByTimePeriod } from '~/utils/dateRangeUtils';
import { rangePickerDate } from '~/utils/dateUtils';
import { segmentTagsToString } from '~/utils/segments';
import { trpc } from '~/utils/trpc';
import { TimePeriod } from '~server/graphql/generated/graphql';
import { ChartUnion } from '~server/trpc/dashboard/types/dashboards';
import { CustomDashboardQueryCommon } from '~server/trpc/dashboard/types/queries';
import { ONE_MINUTE_IN_MILLIS } from '~server/util/time-period-utils';

import { WhyLabsLoadingOverlay } from '../design-system';
import { PieChart, PieSeries } from './PieChart';

const QUERY_REFRESH_TIME = 5 * ONE_MINUTE_IN_MILLIS; // refresh every 5 minutes

export interface VizDashboardProps {
  chart: ChartUnion;
  id: string;
}

const useStyles = createStyles(() => ({
  pieRoot: {
    display: 'flex',
    flexDirection: 'row',
    justifyContent: 'center',
  },
}));

export const VizDashboard = ({ chart, id }: VizDashboardProps) => {
  const orgId = useOrgId();
  const { classes } = useStyles();

  const {
    dateRange: { from: startTimestamp, to: endTimestamp },
    loading: loadingDateRange,
  } = useSuperGlobalDateRange({
    timePeriod: TimePeriod.Pt1H,
  });

  const isPieChart = 'pie' in chart;

  const isQueryEnabled = !loadingDateRange;
  const fromTimestamp = startTimestamp ?? 0;
  const toTimestamp = endTimestamp ?? 0;

  let plotsCount = 0;

  const chartToQuery: ChartUnion = (() => {
    const common = {
      ...chart,
      // The server doesn't care about the displayName, so we can safely remove it to avoid unnecessary calls
      displayName: '',
    };

    if (isPieChart) {
      // Don't include displayName to avoid unnecessary calls to the server
      const pie = chart.pie?.map(({ displayName, ...s }) => s) ?? [];
      plotsCount = pie.length;

      return {
        ...common,
        pie,
      };
    }

    // Don't include displayName to avoid unnecessary calls to the server
    const timeseries = chart.timeseries?.map(({ displayName, ...t }) => t) ?? [];
    plotsCount = timeseries.length;

    return {
      ...common,
      timeseries,
    };
  })();
  const {
    data: queryData,
    isLoading,
    error,
  } = trpc.metrics.simple.getList.useQuery(
    {
      orgId: orgId ?? '',
      fromTimestamp,
      toTimestamp,
      chart: chartToQuery,
    },
    {
      enabled: isQueryEnabled,
      staleTime: QUERY_REFRESH_TIME,
    },
  );

  useTrpcServerErrorHandler(error);

  const higherBatchFrequency = queryData?.timePeriod ?? TimePeriod.P1D;

  const lineSeries: ChartTimeSeries[] = [];

  const pieSeries: PieSeries[] = [];

  queryData?.series?.forEach(({ column, data, queryId, resourceId: resId, type, ...rest }, index) => {
    const query = (() => {
      const findByQueryId = (common: CustomDashboardQueryCommon) => common.queryId === queryId;

      if (isPieChart) return chart.pie.find(findByQueryId);
      return chart.timeseries.find(findByQueryId);
    })();

    const querySegment = query && 'segment' in query && query.segment?.length ? query.segment : undefined;
    const hasWildCardSegment = !!querySegment?.find(({ value }) => value === '*');

    if (type === 'pie') {
      const autoGeneratedName = (() => {
        const name = `${resId}:${column}`;
        if (!querySegment) return name;

        return `${name}:${segmentTagsToString(querySegment)}`;
      })();

      pieSeries.push({
        color: query?.color,
        data,
        id: `${autoGeneratedName}_${index}`,
        title: query?.displayName || autoGeneratedName,
        subtitle: `Total for ${rangePickerDate(fromTimestamp)} to ${rangePickerDate(toTimestamp)}`,
      });
    }

    if (type === 'timeseries') {
      const autoGeneratedName = (() => {
        const metricString = 'metric' in rest ? query?.metricLabel ?? rest.metric : '';

        const text = `${resId}:${metricString.toLowerCase()}:${column}`;
        if (!querySegment || hasWildCardSegment) return text;

        return `${text}:${segmentTagsToString(querySegment)}`;
      })();

      const name = (() => {
        const text = query?.displayName || autoGeneratedName;

        if (hasWildCardSegment) {
          return `${text}:${segmentTagsToString(rest.segment)}`;
        }

        return text;
      })();

      const color = (() => {
        // Sum plotsCount to prevent using the same color that other plots already use
        if (hasWildCardSegment) return chartColorForIndex(index + plotsCount);

        return query?.color;
      })();

      lineSeries.push({
        type: 'line',
        color,
        id: `${autoGeneratedName}_${index}`,
        name,
        data: data.map((d) => [d.timestamp, d.value]),
      });
    }
  });

  const { startFn } = rangeTranslatorByTimePeriod.get(higherBatchFrequency) ?? {};

  if (isQueryEnabled && isLoading) return <WhyLabsLoadingOverlay visible />;

  const shouldRenderEmpty = isPieChart ? !pieSeries.length : !lineSeries.length;
  if (!isQueryEnabled || shouldRenderEmpty) return <EmptySelectionGraphCard />;

  if (isPieChart) {
    return (
      <div className={classes.pieRoot} id={id}>
        {pieSeries.map((series) => (
          <PieChart description="" height={340} id={series.id} key={series.id} {...series} />
        ))}
      </div>
    );
  }

  return (
    <>
      <TimeSeriesChart
        description=""
        id={id}
        height={340}
        series={lineSeries}
        spec={{
          xAxis: {
            max: startFn?.(toTimestamp).getTime(),
            min: fromTimestamp,
          },
          yAxis: [
            {
              title: 'Value',
            },
          ],
        }}
      />
    </>
  );
};
