from typing import Optional, List
import pandas as pd

from whylabs_toolkit.monitor.models import Analyzer

from smart_config.server.dataservice.constants import (
    MAX_ANALYSIS_RESULTS,
)
from whylabs_toolkit.monitor.diagnoser.constants import MAX_COLUMNS
from whylabs_toolkit.monitor.diagnoser.helpers.describe import describe_truncated_list
from smart_config.server.diagnosis.condition import Condition
from smart_config.server.diagnosis.diagnostic_data import DiagnosticData
from smart_config.server.diagnosis.icondition_describer import IConditionDescriber
from smart_config.server.diagnosis.quality_issue import QualityIssue, QualityIssueName


class ConditionDetector(IConditionDescriber):
    condition: str = None
    required_data: List[str] = []
    summary: str = condition

    def check(self, analyzer: Analyzer, data: DiagnosticData) -> Optional[Condition]:
        return None

    def matches_analyzer(self, analyzer: Analyzer) -> bool:
        return False
    
    def summarize(self, condition: Condition) -> str:
        return self.summary.format(**condition.info) if condition.info else self.summary

    def describe(self, condition: Condition) -> str:
        """
        Default description of a condition generated by this detector. Detectors should override for more useful info.
        :param condition:
        :return: str
        """
        cols = condition.columns
        if self.condition != condition.name:
            raise Exception(f'Detector {self.condition} asked to describe condition {condition.name}')
        description = f'\n\t* Condition {self.condition} ({self.summarize(condition)})'
        if cols is not None:
            if len(cols) > 10:
                col_text = describe_truncated_list(cols)
            else:
                col_text = str(cols[0:10])

            description += f' for {len(cols)} columns: {col_text}'
        return description

    def missing_data(self, analyzer: Analyzer, data: DiagnosticData) -> List[QualityIssue]:
        return [QualityIssue(QualityIssueName.missing_diagnostic_data, analyzer.id, self.condition, k) for k in
                self.required_data if getattr(data, k, None) is None]

    def poor_data(self, analyzer: Analyzer, data: DiagnosticData) -> List[QualityIssue]:
        poor = []
        batch_names = ['analysis_results', 'diagnostic_batches']
        batch_fields = ['datasetTimestamp', 'timestamp']
        for i, name in enumerate(batch_names):
            batches = getattr(data, name, None)
            if name in self.required_data and batches is not None and len(pd.unique(batches[batch_fields[i]])) < 10:
                poor.append(QualityIssue(QualityIssueName.limited_diagnostic_data, analyzer.id, self.condition, name))
        return poor

    def analyzer_change(self, analyzer: Analyzer, data: DiagnosticData) -> List[QualityIssue]:
        if data.analysis_results is None:
            return []
        if data.analyzer.metadata and data.analyzer.metadata.updatedTimestamp > data.analysis_results['datasetTimestamp'].min():
            return [QualityIssue(QualityIssueName.analyzer_changed, analyzer.id, self.condition)]
        return []

    def too_many_analysis_results(self, analyzer: Analyzer, data: DiagnosticData) -> List[QualityIssue]:
        if data.analysis_results is None:
            return []
        if len(data.analysis_results) == MAX_ANALYSIS_RESULTS and 'analysis_results' in self.required_data:
            return [QualityIssue(QualityIssueName.too_many_analysis_results, analyzer.id, self.condition)]
        return []

    def too_many_columns(self, analyzer: Analyzer, data: DiagnosticData) -> List[QualityIssue]:
        if data.analysis_results is None:
            return []
        if len(data.cols_with_anomalies) > MAX_COLUMNS:
            return [QualityIssue(QualityIssueName.too_many_columns, analyzer.id, self.condition)]
        return []

    def quality_check(self, analyzer: Analyzer, data: DiagnosticData) -> List[QualityIssue]:
        issues = []
        for check in ['missing_data', 'poor_data', 'analyzer_change', 'too_many_analysis_results', 'too_many_columns']:
            issues.extend(getattr(self, check)(analyzer, data))
        return issues
