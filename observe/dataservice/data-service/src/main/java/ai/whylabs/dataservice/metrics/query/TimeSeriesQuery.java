package ai.whylabs.dataservice.metrics.query;

import ai.whylabs.dataservice.metrics.agg.MetricAggregationLevel;
import ai.whylabs.dataservice.metrics.spec.BuiltinMetric;
import ai.whylabs.dataservice.metrics.spec.Datasource;
import ai.whylabs.dataservice.metrics.spec.NumericMetric;
import ai.whylabs.dataservice.requests.SegmentTag;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonPropertyDescription;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.Collections;
import java.util.List;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.val;

@EqualsAndHashCode(callSuper = true)
@Data
@JsonTypeInfo(
    use = JsonTypeInfo.Id.NAME,
    property = "datasource",
    defaultImpl = ProfileTimeSeriesQuery.class)
@JsonSubTypes({
  @JsonSubTypes.Type(value = ProfileTimeSeriesQuery.class, name = Datasource.PROFILE),
  @JsonSubTypes.Type(value = MonitorTimeSeriesQuery.class, name = Datasource.MONITOR),
  @JsonSubTypes.Type(value = TraceTimeSeriesQuery.class, name = Datasource.TRACE),
})
@Schema(requiredProperties = "datasource")
public abstract class TimeSeriesQuery extends MetricQuery {

  @JsonPropertyDescription("Read analysis generated by the PG backed monitors")
  private boolean readPgMonitor = false;

  abstract BuiltinMetric getMetric();

  @JsonIgnore
  abstract NumericMetric getCustom();

  @Schema(
      example = "[{\"key\": \"region\", \"value\": \"us-east-1\"}]",
      description = "Optional, filter by segment tags. Uses [] if not specified")
  List<SegmentTag> segment = Collections.emptyList();

  @JsonIgnore
  public List<NumericMetric> getEffectiveMetrics() {
    if (getCustom() != null) {
      return ImmutableList.of(getCustom());
    }

    return getMetric().getMetrics();
  }

  @JsonIgnore
  public FormulaQuery getEmbeddedFormula() {
    if (getMetric() != null && getMetric().getFormula() != null) {
      val f = new FormulaQuery();
      f.setQueryId(this.queryId);
      f.setPrefixResults(true);
      f.setFormula(getMetric().getFormula());
      return f;
    }
    return null;
  }

  @Override
  public void validate() {
    super.validate();
    getEffectiveMetrics()
        .forEach(
            m -> {
              Preconditions.checkArgument(
                  !(columnName != null && m.getColumnName() != null),
                  "columnName and metric.columnName cannot be both specified: %s",
                  m);
              if (m.getEffectiveSpec()
                  .getSupportedLevels()
                  .contains(MetricAggregationLevel.RESOURCE)) {
                Preconditions.checkArgument(resourceId != null, "resourceId is required");
              }
              if (m.getEffectiveSpec()
                  .getSupportedLevels()
                  .contains(MetricAggregationLevel.COLUMN)) {
                Preconditions.checkArgument(resourceId != null, "resourceId is required");
              }
            });

    if (resourceId == null && (segment != null && !segment.isEmpty())) {
      throw new IllegalArgumentException("Cannot specify segment without resourceId");
    }
  }
}
